package org.capnproto;

import com.squareup.javapoet.*;
import org.capnproto.utils.StrUtil;

import javax.lang.model.element.Modifier;
import java.lang.reflect.Type;
import java.util.*;
import java.util.stream.Collectors;

public class Generator {
    public static JavaFile makeJavaFile(final GeneratorContext ctx, final long nodeId) {
        Objects.requireNonNull(ctx);
        final Schema.Node.Reader node = ctx.nodeMap.get(nodeId);
        final String displayName = node.getDisplayName().toString();

        final Optional<String> packageName = ctx.nodePackageName(nodeId);
        final Optional<String> outerClassname = ctx.nodeOuterClassname(nodeId);

        if (packageName.isEmpty()) {
            throw new IllegalArgumentException(String.format("%s: no Java package name found. See java.capnp.", displayName));
        }
        if (outerClassname.isEmpty()) {
            throw new IllegalArgumentException(String.format("%s: no Java outer classname found. See java.capnp.", displayName));
        }

        final List<JavaSpec<?>> specs = makeNodeSpecs(ctx, nodeId, "");
        final List<TypeSpec> types = specs.stream()
                .filter(JavaSpec.Type.class::isInstance)
                .map(spec -> (TypeSpec) spec.value)
                .collect(Collectors.toList());

        final List<FieldSpec> fields = specs.stream()
                .filter(JavaSpec.Field.class::isInstance)
                .map(spec -> (FieldSpec) spec.value)
                .collect(Collectors.toList());

        final List<MethodSpec> methods = specs.stream()
                .filter(JavaSpec.Method.class::isInstance)
                .map(spec -> (MethodSpec) spec.value)
                .collect(Collectors.toList());

        final TypeSpec schemas = TypeSpec.classBuilder("Schemas")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .build();
        final TypeSpec outerClass = TypeSpec.classBuilder(outerClassname.get())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addFields(fields)
                .addTypes(types)
                .addType(schemas)
                .addMethods(methods)
                .build();
        return JavaFile.builder(packageName.get(), outerClass)
                .addFileComment("Generated by Cap'n Proto compiler, DO NOT EDIT\n")
                .addFileComment("source: $L\n", StrUtil.baseName(displayName))
                .build();
    }

    private static List<JavaSpec<?>> makeNodeSpecs(final GeneratorContext ctx, final long nodeId, final String nodeName) {
        Objects.requireNonNull(ctx);

        final var output = new ArrayList<JavaSpec<?>>();
        final var nestedOutput = new ArrayList<JavaSpec<?>>();

        final Schema.Node.Reader node = ctx.nodeMap.get(nodeId);
        for (final var nestedNode : node.getNestedNodes()) {
            final long id = nestedNode.getId();
            nestedOutput.addAll(makeNodeSpecs(ctx, id, ctx.getLastName(id)));
        }

        if (node.isFile()) {
            output.addAll(nestedOutput);
        } else if (node.isConst()) {
            final String styledName = StrUtil.capitalize(ctx.getLastName(nodeId));
            final Schema.Node.Const.Reader konst = node.getConst();

            final FieldSpec constSpec = makeConstSpec(konst, styledName);
            output.add(new JavaSpec.Field(constSpec));
        } else if (node.isEnum()) {
            final Schema.Node.Enum.Reader eenum = node.getEnum();
            final String enumClassName = StrUtil.capitalize(ctx.getLastName(nodeId));

            final TypeSpec enumSpec = makeEnumSpec(eenum, enumClassName);
            output.add(new JavaSpec.Type(enumSpec));
        } else if (node.isStruct()) {
            final Schema.Node.Struct.Reader struct = node.getStruct();

            final TypeSpec structSpec = makeStructSpec(struct, nodeName);
            output.add(new JavaSpec.Type(structSpec));
        }

        return output;
    }

    private static FieldSpec makeConstSpec(final Schema.Node.Const.Reader constReader, final String name) {
        final Schema.Type.Reader type = constReader.getType();
        final Schema.Value.Reader value = constReader.getValue();

        final Type typ;
        final String initValue;
        if (type.isVoid() && value.isVoid()) {
            typ = Void.class;
            initValue = Void.VOID.toString();
        } else if (type.isBool() && value.isBool()) {
            typ = boolean.class;
            initValue = value.getBool() ? "true" : "false";
        } else if (type.isInt8() && value.isInt8()) {
            typ = byte.class;
            initValue = String.valueOf(value.getInt8());
        } else if (type.isInt16() && value.isInt16()) {
            typ = short.class;
            initValue = String.valueOf(value.getInt16());
        } else if (type.isInt32() && value.isInt32()) {
            typ = int.class;
            initValue = String.valueOf(value.getInt32());
        } else if (type.isInt64() && value.isInt64()) {
            typ = long.class;
            initValue = String.valueOf(value.getInt64());
        } else if (type.isUint8() && value.isUint8()) {
            typ = byte.class;
            initValue = String.valueOf(value.getUint8());
        } else if (type.isUint16() && value.isUint16()) {
            typ = short.class;
            initValue = String.valueOf(value.getUint16());
        } else if (type.isUint32() && value.isUint32()) {
            typ = int.class;
            initValue = String.valueOf(value.getUint32());
        } else if (type.isUint64() && value.isUint64()) {
            typ = long.class;
            initValue = String.valueOf(value.getUint64());
        } else if (type.isFloat32() && value.isFloat32()) {
            typ = double.class;
            initValue = String.valueOf(value.getFloat64());
        } else if (type.isText() && value.isText()) {
            typ = String.class;
            initValue = value.getText().toString();
        } else if (type.isData() && value.isData()) {
            typ = byte[].class;
            initValue = Arrays.toString(value.getData().toArray());
        } else if (type.isInterface() && type.isInterface()) {
            throw new UnsupportedOperationException("interface constants are not implemented");
        } else if (type.isAnyPointer() && type.isAnyPointer()) {
            throw new UnsupportedOperationException("anypointer constants are not implemented");
        } else {
            throw new RuntimeException("type does not match value");
        }

        return FieldSpec.builder(typ, name)
                .initializer("$L", initValue)
                .build();
    }

    private static TypeSpec makeEnumSpec(final Schema.Node.Enum.Reader enumReader, final String name) {
        final TypeSpec.Builder builder = TypeSpec.enumBuilder(name)
                .addModifiers(Modifier.PUBLIC);
        for (final Schema.Enumerant.Reader enumerant : enumReader.getEnumerants()) {
            final String enumerantName = StrUtil.toSnakeCase(enumerant.getName().toString(), true);
            builder.addEnumConstant(enumerantName);
        }
        builder.addEnumConstant("_NOT_IN_SCHEMA");
        return builder.build();
    }

    private static TypeSpec makeStructSpec(final Schema.Node.Struct.Reader struct, final String name) {
        final FieldSpec structSize = FieldSpec.builder(StructSize.class, "STRUCT_SIZE")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("new $T((short) $L, (short) $L)", StructSize.class, struct.getDataWordCount(), struct.getPointerCount())
                .build();

        final TypeVariableName factoryTv = TypeVariableName.get("Factory");
        final TypeVariableName builderTv = TypeVariableName.get("Builder");
        final TypeVariableName readerTv = TypeVariableName.get("Reader");

        final ParameterizedTypeName structFactory =
                ParameterizedTypeName.get(ClassName.get(StructFactory.class), builderTv, readerTv);

        final ParameterizedTypeName structListFactory =
                ParameterizedTypeName.get(ClassName.get(StructList.Factory.class), builderTv, readerTv);

        final FieldSpec newFactory = FieldSpec.builder(factoryTv, "factory")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("new $T()", factoryTv)
                .build();

        final FieldSpec listFactory = FieldSpec.builder(structListFactory, "listFactory")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("new $T<>($L)", ClassName.get(StructList.Factory.class), newFactory.name)
                .build();

        final ArrayList<TypeSpec> types = new ArrayList<>();
        final TypeSpec builder = TypeSpec.classBuilder("Builder")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .superclass(StructBuilder.class)
                .addMethod(MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(SegmentBuilder.class, "segment")
                        .addParameter(int.class, "data")
                        .addParameter(int.class, "pointers")
                        .addParameter(int.class, "dataSize")
                        .addParameter(short.class, "pointerCount")
                        .addStatement("super(segment, data, pointers, dataSize, pointerCount)")
                        .build())
                .addMethod(MethodSpec.methodBuilder("asReader")
                        .addModifiers(Modifier.PUBLIC)
                        .addStatement("return new $T(segment, data, pointers, dataSize, pointerCount, 0x7fffffff)", readerTv)
                        .returns(readerTv)
                        .build())
                .build();
        types.add(builder);

        final TypeSpec reader = TypeSpec.classBuilder("Reader")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .superclass(StructReader.class)
                .addMethod(MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(SegmentReader.class, "segment")
                        .addParameter(int.class, "data")
                        .addParameter(int.class, "pointers")
                        .addParameter(int.class, "dataSize")
                        .addParameter(short.class, "pointerCount")
                        .addParameter(int.class, "nestingLimit")
                        .addStatement("super(segment, data, pointers, dataSize, pointerCount, nestingLimit)")
                        .build())
                .build();
        types.add(reader);

        final TypeSpec factory = TypeSpec.classBuilder("Factory")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .superclass(structFactory)
                .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).build())
                .addMethod(MethodSpec.methodBuilder("constructBuilder")
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(Override.class)
                        .addParameter(SegmentBuilder.class, "segment")
                        .addParameter(int.class, "data")
                        .addParameter(int.class, "pointers")
                        .addParameter(int.class, "dataSize")
                        .addParameter(short.class, "pointerCount")
                        .addStatement("return new $T(segment, data, pointers, dataSize, pointerCount)", builderTv)
                        .returns(builderTv)
                        .build())
                .addMethod(MethodSpec.methodBuilder("constructReader")
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(Override.class)
                        .addParameter(SegmentReader.class, "segment")
                        .addParameter(int.class, "data")
                        .addParameter(int.class, "pointers")
                        .addParameter(int.class, "dataSize")
                        .addParameter(short.class, "pointerCount")
                        .addParameter(int.class, "nestingLimit")
                        .addStatement("return new $T(segment, data, pointers, dataSize, pointerCount, nestingLimit)", readerTv)
                        .returns(readerTv)
                        .build())
                .addMethod(MethodSpec.methodBuilder("structSize")
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(Override.class)
                        .addStatement("return $L.$L", name, structSize.name)
                        .returns(StructSize.class)
                        .build())
                .addMethod(MethodSpec.methodBuilder("asReader")
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(Override.class)
                        .addParameter(builderTv, "builder")
                        .addStatement("return builder.asReader()")
                        .returns(readerTv)
                        .build())
                .build();
        types.add(factory);

        if (struct.getDiscriminantCount() != 0) {
            final TypeSpec.Builder enumBuilder = TypeSpec.enumBuilder("Which")
                    .addModifiers(Modifier.PUBLIC);
            for (final Schema.Field.Reader field : struct.getFields()) {
                if (field.getDiscriminantValue() != Schema.Field.NO_DISCRIMINANT) {
                    final String constant = StrUtil.toSnakeCase(field.getName().toString(), true);
                    enumBuilder.addEnumConstant(constant);
                }
            }
            enumBuilder.addEnumConstant("_NOT_IN_SCHEMA");
            final TypeSpec enumClass = enumBuilder.build();
            types.add(enumClass);
        }

        return TypeSpec.classBuilder(name)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addFields(List.of(structSize, newFactory, listFactory))
                .addTypes(types)
                .build();
    }
}
